# msImportExport 1.0

Компонент для импорта/экспорта товаров [MiniShop2](https://modstore.pro/packages/ecommerce/minishop2) на сайт из/в CSV/XLSX, а также экспорт в Яндекс.Маркет.

## Видео-обзор

[Видео-обзор](https://www.youtube.com/watch?v=e-1WLTRmA4I)

## Интеграция

msImportExport интегрирован с дополнениями:

- [msOptionsPrice2](https://modstore.pro/packages/ecommerce/msoptionsprice2)
- [msOptionsColor](https://modstore.pro/packages/integration/msoptionscolor)
- [msProductRemains](https://modstore.pro/packages/ecommerce/msproductremains)
- [msSalePrice](https://modstore.pro/packages/discounts/mssaleprice)
- [ms2Gallery](https://modstore.pro/packages/photos-and-files/ms2gallery)
- [SEO Pro](https://modx.com/extras/package/seopro)

## Требования к структуре каталогов

Базовый каталог (категория) и все его подкаталоги должны быть типа «Товар категория». Каталогам будет считаться любая «Товар категория» у которой нет родителя

## Какой тип файла выбрать?

Если в файле нет полей типа content т/е полей которые могут содержать символ новой строки, то лучше использовать csv файл (utf-8 кодировка) т/к для импорта из него необходимо меньше ресурсов и времени.

## Cписок факторов/рекомендаций которые могут влиять на скорость импорта

- если в файле нет полей типа content т/е полей которые могут содержать символ новой строки, то лучше использовать csv файл ( utf-8 кодировка) т/к для импорта из него необходимо меньше ресурсов и времени.
- не тулить в файл импорта поля которые не будут импортироваться
- по возможности отказаться от использований tv и опций и где это возможно заменить на поля созданные через систему плагинов [minishop2](/components/minishop2/development/product-plugins) или использовать дополнение [msFieldsManager](https://modstore.pro/packages/integration/msfieldsmanager) т/к это увеличит как скорость работы сайта так и импорта (каждая и опция это лишний sql запрос к базе данных и количество подзапросов в mysql лимитировано )
- по возможности при импорте фото указывать локальный к ним путь, а не http/https т/к тогда тратится время на их скачивание на сервер
- поля которое указано в опции «Ключ товара, по которому определяется его уникальность» если там поле типа pagetitle по скорость будет меньше т/к в БД для этого поля нет индекса поэтому если у вас свое кастомное поле добавьте для него в БД индекс
- количество уже имеющихся товаров в minishop2
- размер файла импорта, если он очень большой то по возможности его стоит разбить на меньшие т/к тогда меньше тратится времени и ресурсов сервера на смещение указателя чтения для новой итерации
- импорт через cron также использует чуть меньше расход ресурсов, а также позволяет частично решить проблему timeout. Дополнительная инфа по настройки сервера для работы с большими файлами есть в доках дополнения в разделе “Импорт больших файлов”
- другие дополнения, которые могут срабатывать при определенных событиях minishop2 и делать свои какие то манипуляции с данными

## Импорт

### Импорт товара

Файл импорта должен содержать как минимум 2 обязательных поля pagetitle и поле которое указанов в настройках импорта в опции **“Ключ товара, по которому определяется его уникальность”** (по умолчанию “article”)

Описание настройки основных полей:

**parent** — может содержать как ID так и название (pagetitle) категории к которой относится товар, если для
товара не задано данное поле то в зависимости от настроек такой товар будет проигнорирован или же добавлен в базовый
каталог. При указании в parent название категории в случае ее отсутствия на сайте она будет автоматически создана, можно
также указывать вложенные категории (начиная с базового каталога) разделяя их разделителем который указав в
настройках в поле **“Дополнительный разделитель для полей типа JSON”** (по умолчанию это | ) в таком случае если
какой то из категорий не будет она также будет создана. Пример Base category|category1|category2 в базовом каталоге
(Каталог) будет создана категория category1 которая будет содержать подкатегорию category2 которая будет использована в parent для товара.

**categories** — позволяет один и тот же товар отнести сразу к нескольким категориям в качестве значения принимает названия (pagetitle) или ID. Можно указывать несколько категорий через разделитель который указав в настройках в поле **“Дополнительный разделитель для полей типа JSON”** (по умолчанию это | ) в случае если какой то из категорий не будет она также будет создана. Через 2-й дополнительный разделитель ( по умолчагию % ) можно указать вложенной для дополнительной категории которая будет создана в случае отсутствия.

**Пример:**

| parent    | categories                                             |
|-----------|--------------------------------------------------------|
| category1 | `sub_category1&#10072;sub_category2%sub_sub_category2` |

Товар будет создан в категории category1 но также будет доступен в подкатегории sub_category1 и sub_sub_category2

**vendor** — можно указать как ID так и название производителя, если производитель с заданным названием не будет
найден то он будет создан

**gallery** — путь к изображению для галерее может быть как локальный (относительно указанного в настройках
импорта опция **«Базовый директория для изображений»)** так и http/https ссылкой на сторонний ресурс (при использовании http/https ссылк импорт происходит меделенней). Через
дополнительный разделитель (по умолчанию это | ) можно указать сразу несколько фото.

**Пример:**

```
assets/pic/pic2.jpeg|assets/pic/pic3.jpg
```

**alias** — данное поле, как правило, импортировать не нужно т/к он автоматически создается Modx на основании значения из pagetitle отсюда следует, что pagetitle должно быть уникально относительно категории.

**Дополнительные опции и TV** — импорт пользовательских опции и TV поддерживаются, если они в качестве значения
содержат список то данные нужно указывать через дополнительный разделитель (по умолчанию это | )

**Пример импорт цвета для товара:**

```
Зеленый|Красный
```

### Импорт категорий

Вы можете сделать отдельно импорт чисто категорий товаров. Файл импорта должен содержать как минимум поля — pagetitle, parent и поле которое указанов в настройках импорта в опции **“Ключ товара, по которому определяется его уникальность”**

**parent** может содержать как ID так и цепочки из названий (pagetitle) родительских категории разделенных разделителем который указав в настройках в поле **“Дополнительный разделитель для полей типа JSON”** (по умолчанию это | ) в таком случае если какой то из категорий не будет она также будет создана.

**Пример:**

| pagetitle | parent                                            |
|-----------|---------------------------------------------------|
| category3 | `Base category&#10072;category1&#10072;category2` |

В этом примере category3 будет создана в category2 вся цепочка из parent так же будет создана.

### Импорт связей

Файл импорта должен содержать 3 поля:

- **link** — id связи из списка настроек связей minishop2
- **master** — id главного товара
- **slave** — id подчиненного товара

Если при импорте id главного и подчиненного товара могут не совопадать (файл импорта был получен в реультате экспорта
с другого сайта) то id можно заменить на любой другой идентификатор по которому можно будет найти товар, например article, после чего указать его название в настройках импорта в опции **“Ключ товара, по которому определяется его уникальность”**

**Пример:**

| link | master_article | slave_article |
|------|----------------|---------------|
| 1    | 00000100       | 00000200      |
| 1    | 00000100       | 00000300      |

### Импорт галереи

Поддерживается импорт как в родную галерею minishop2, так и в MS2Gallery верии 2.0 или выше. При использовании MS2Gallery в качестве галереии для товаров следует учесть тот момент, что MS2Gallery синхронизирует изображения с родной галерей minishop2 тоесть происходит дублировани информации о изображении в 2 таблице БД вследствии чего импорт происходит менленней чем если бы вы использовали родную галерею minishop2. Если вы веже решили использовать MS2Gallery то в настройках импорта следуете указать это в опции «Тип галереи» выбрав в выподающем списке «MS2Gallery».

Файл импорта должен содержать минимум 2 поля:

- идентификатор по которому можно будет найти товар (id, article и т/д). Его название следует указать в настройках импорта в опции **“Ключ товара, по которому определяется его уникальность”**

- **file** — путь к изображению для галерее может быть как локальный (относительно указанного в настройках импорта
  опция **«Базовый директория для изображений»**) так и
  http/https ссылкой на сторонний ресурс (при использовании http/https ссылк импорт происходит меделенней)

### Импорт msProductRemains

Если у вас установлен компонент [msProductRemains](https://modstore.pro/packages/ecommerce/msproductremains) версии 2.1.18-pl или выше, то тогда у вас появится возможность импортировать остатки товаров.

Для того чтобы быстро обновить значения остатков, файл импорта должен содержать 2 поля — ID остатка и само значение остатка.

**Пример**:

| mspr:id | mspr:remains |
|---------|--------------|
| 2       | 1            |
| 3       | 2            |

Файлы импорт/обновления опций остатков могут быть таких вариаций:

1. ID остатка
2. опции остатка
2. остаток (не обязательно)

| mspr:id | mspr:options | mspr:remains |
|---------|--------------|--------------|
| 2       | Red&#10072;S | 1            |
| 3       | Red&#10072;M | 2            |

1. ID товара
2. опции остатка
3. остаток (не обязательно)

| mspr:product_id | mspr:options | mspr:remains |
|-----------------|--------------|--------------|
| 3               | Red&#10072;S | 1            |
| 3               | Red&#10072;M | 2            |

1. Значения поля которое указано в «Ключ товара, по которому определяется его уникальность»
2. опции остатка
3. остаток (не обязательно)

| article   | mspr:options | mspr:remains |
|-----------|--------------|--------------|
| article-1 | Red&#10072;S | 1            |
| article-1 | Red&#10072;M | 2            |

**Важно!** Опции для остатка должны быть в такой же последовательности в какой они указаны в настройках
msProductRemains (ключ mspr_options) и разделены символом который у вас указан в настройки **«Дополнительный
разделитель для полей типа JSON»**

Сделав экспорт остатков вы сможете получить структуру своего файла импорта.

![Структура файла импорта](https://file.modx.pro/files/5/a/b/5ab4961d7bce7a3763b3ebcb4626bab0.png)

### Импорт msOptionsPrice2

Если у вас установлен компонент [msOptionsPrice2](https://modstore.pro/packages/ecommerce/msoptionsprice2), то у вас появится возможность импорта модификаций товара.

**Название основных полей модификации:**

- name — название модификации
- type — тип модификации цены может иметь значение 1|2|3 что соответствует =|+|и -
- price — цена
- old_price — старая цена
- article — артикул для модификации(не одно и тоже что и для товара)
- weight — вес
- count — количество
- image — изображение (должно содержать название изображения которое уже есть у товара)
- active — активна ли модификация, может принимать значение 0|1

Все поля которые могут быть использованы для модификации товара будут в выпадающем списке иметь постфикс
"(msOptionsPrice2)". Чтобы корректно работала функция «автоопределение полей» у полей которые относятся к модификации товара должен быть префикс «msop:».

**Существует 2 возможности импорта модификаций товара:**

1. Импортировать только модификации товара (товар должен уже существовать). Для этого нужно в «Тип импорта» выбрать «Импорт OptionsPrice2». В файле должно обязательно присутствовать поле которое указано в опции «Ключ товара, по которому определяется его уникальность»

    **Пример файла импорта:**

    | article  | msop:name                  | msop:type | msop:price | msop:active | msop:image | msop:time |
    |----------|----------------------------|-----------|------------|-------------|------------|-----------|
    | 00000100 | Замена дисплея и тачскрина | 1         | 600        | pic3.jpeg   | 2 часа     |           |
    | 00000100 | Замена аккумулятора        | 1         | 700        |             | 2 часа     |           |

    msop:time — пользовательская переменная которая может быть создана через дополнительные опции или систему плагинов.

2. Классический импорт товара, на ряду с обычными полями товара появятся поля у которых будет постфикс "(msOptionsPrice2)"

    **Пример файла импорта:**

    | article  | pagetitle        | color   | msop:name                  | msop:type | msop:price | msop:active | msop:image | msop:time |
    |----------|------------------|---------|----------------------------|-----------|------------|-------------|------------|-----------|
    | 00000100 | Тестовый товар 1 | Красный | Замена дисплея и тачскрина | 1         | 600        | pic3.jpeg   | 2 часа     |           |
    | 00000100 | Тестовый товар 1 | Красный | Замена аккумулятора        | 1         | 700        |             | 2 часа     |           |
    | 00000200 | Тестовый товар 2 | Красный |                            |           |            |             |            |           |

Каждый из способов имеет свои плюсы и минусы. Первый стоит использовать когда вы уверены, что товар для которого вы делаете импорт модификаций уже существует. Второй стоит использовать кода товара может еще не быть. Минус 2-го варианта в том, что будет для каждой модификации одного и того же товара повторно будет происходить и обновление товара.

## Быстрое обновление данных товара

Быстрое обновление данных товара используется только для обновления данных непосредственно товара (таблица ms2_products) никакие TV и дополнительные опции не обновляются, но обновляются данные добавленные через систему плагинов minishop2 или через дополнение [msFieldsManager](https://modstore.pro/packages/integration/msfieldsmanager). Обновления происходит чисто через sql запросы к БД минуя процессоры modx. В файле с данными, для каждого товара должно обязательно присутствовать поле которое указана в настройках в опции **“Ключ товара, по которому определяется его уникальность”**.

## Экспорт

Перед тем как сделать экспорт необходимо для каждого типа экспорта сделать настройку полей которые вы хотите экспортировать.

Настройка полей делается на вкладке «Настройки экспорта» в разделе «CSV/Excel Файл» и состоит из следующих шагов:

1. выбрать тип экспорта

    ![выбрать тип экспорта](https://file.modx.pro/files/a/4/3/a439e9d445fde1003a5e224b9b6a75b5.jpg)

2. создать (если еще нет) название для настройки полей, для этого необходимо нажать кнопку с шестиренкой.

    ![создать (если еще нет) название для настройки полей](https://file.modx.pro/files/8/c/a/8ca73abca4a2aa184237e0732e899780.jpg)

3. выбрать название настройки для полей в списке «Список настроек полей»

    ![ выбрать название настройки для полей](https://file.modx.pro/files/0/8/1/081ac7bccfeca6cc0113bc441ab4ded1.jpg)

4. добавить нужное количество полей, выбрать для них названия из выподающего списка после чего нажать на кнопку «Сохранить настройки»

    ![добавить нужное количество полей](https://file.modx.pro/files/2/5/c/25c0a5ef5c22a83222d4f3b4337e372c.jpg)

5. После создания настройки полей можно приступить непосредственно к экспорту выбрав нужные значения из списков.

    ![После создания настройки полей можно приступить непосредственно к экспорту](https://file.modx.pro/files/f/9/c/f9cdd8f09c1f423faf58fcd8d46d5bc6.jpg)

Для экспорта модификаций товаров (msOptionsPrice2) в Яндекс.Маркет необходимо добавить название ваших полей (которые были созданы через дополнительные опции или систему плагинов) в настройках экспорта в список «Поля характеристик товара».

## Сниппет MsieBtnDownloadPrice

**MsieBtnDownloadPrice** — cниппет для вывода кнопки скачивания прайс-листа с фронтенда сайта

**Параметры:**

- **tpl** — чанк оформления для кнопки скачивания. По умолчанию msieBtnDownloadPriceTpl
- **usergroup** — список групп (через запятую) пользователя, которым показывать кнопку скачивания.
- **res** — список категорий, через запятую, для поиска результатов. По умолчанию выборка ограничена текущим родителем
- **preset** — ID настройки полей экспорта. Если данный параметр не указан, то в файле экспарта будут следующие поля: pagetitle,price и href
- **to** — формат файла csv|xlsx. По умолчанию xlsx
- **filename** — название файла
- **where** — строка, закодированная в JSON, с дополнительными условиями выборки
- **element** — Название сниппета возвращающего id товаров через запятую которые должны попасть в прайс-лист. Вы можете указать набор параметров для него: &element=`mySnippen@myParams`. В сниппет автоматически добавляется параметр &returnIds=`1`

Пример вызова сниппета с параметров where. В экспорт попадают товары цена которых > 0

```modx
[[MsieBtnDownloadPrice? &where=`{"Data.price:>":0}`]]
```

Повторное скачивание того же прайса может быть произведено только по истечению 3 минут. Изменить время блокировки скачивания прайс-листа можно на странице системных настроек компонента `/manager/?a=system/settings`

![](https://file.modx.pro/files/6/d/c/6dce83febf89fb7f67abde86b2d84334.jpg)

## CRON Импорт

1. переходим в настройки импорта и находим там раздел “Cron”
2. нажимает на кнопку “Добавить задачу” после чего в появившемся окне заполняем соответствующие поля (путь к файлу с данными для импорта может быть и http/https ссылкой; Времени выполнения задания указывается как в [классическом cron](https://help.ubuntu.ru/wiki/cron))

    ![CRON Импорт](https://file.modx.pro/files/9/1/7/9175e1240ea00fab6ef35c265e4f061d.jpg)

3. нажимает на кнопку сохранить
4. добавляем адрес из “Задание для CRON” в cron у себя на сервере.

    ![добавляем адрес из “Задание для CRON”](https://file.modx.pro/files/a/5/c/a5cde32fb061dacb56436db8caf08932.jpg)

**Cron на серверах beget.ru.**

Т/к на beget.ru запрещено создавать процессы “демоны” то для того что бы импорта по cron все же работал необходимое сделать дополнительные настройки.

- в системных настройках modx включить опцию “Ожидать завершения выполнения скрипта в фоне” (ключ msimportexport.cron_wait )
- убрать символ "&" в конце скрипта для крона

```
...... /core/components/msimportexport/cron.php 1> /dev/null 2>&1 &
```

## CRON Экспорт

Для того, чтобы сделать экспорт по cron необходимо дернуть следующую ссылку

```
/assets/components/msimportexport/export/export.php
```

которая принимает следующие параметры:

1. token — уникальное значение которое можно узнать в настройках экспорта в разделе cron
2. to — (csv|xlsx|xml) по умолчанию csv
3. type — (products|categories|links|options_price2|gallery) по умолчанию products
4. path — путь к директории куда будет сохранен файл по умолчанию assets/components/msimportexport/export
5. preset — ID настройки полей экспорта
6. filename — Название для файла (без расширения)
7. categories — список через запятую ID категорий из которых нужно экспортировать товар (по умолчанию используются из общей настройки экспорта)
8. save — сохранять на сервере по пути из параметра path или же вывести в поток вывода (1|0) по умолчанию 0

**Пример ссылки экспорта продукта в xlsx через wget:**

```
/assets/components/msimportexport/export.php?token=5321a3450db953783b7076a7e72072bb&to=xlsx&type=products&preset=1&save=0
```

**Пример ссылки экспорта продукта в xlsx через консоль:**

```sh
php /assets/components/msimportexport/export.php token=5321a3450db953783b7076a7e72072bb to=xlsx type=products preset=1 save=1
```

### MIGX

Для экспорта MIGX полей необходимо написать свой плагин (событие msieOnBeforeExport) для корректного экспорта JSON данных.

#### Пример плагина

```php
<?php
/**
 * @var modX $modx
 * @var int $preset
 * @var string $section
 * @var array $fields
 * @var array $srcData
 * @var array $destData
 */
// Массив ID настроек полей для которых нужно использовать данный плагин http://prntscr.com/kkwx4r
$presets = array(1,2);
if (!empty($presets) && !in_array($preset, $presets)) return;
switch ($modx->event->name) {
  case 'msieOnBeforeExport':
    if ($section == 'data') {
      $keys = array_flip($fields);
      $tvs = array('tv.my_migx_field','tv.my_migx_field2'); // список TV полей через запятую которы следует преобразовать в строку (обязательно добавлять префикс tv.)
      foreach ($tvs as $tv) {
        if (!isset($keys[$tv]) || empty($srcData[$tv])) continue;
        $index = $keys[$tv];
        $destData[$index] = json_encode($srcData[$tv], JSON_UNESCAPED_UNICODE);
      }
      $modx->event->returnedValues['destData'] = $destData;
    }

  break;
}
```

**Импорт MIGX** полей аналогичный импорту обычных полей, единственно особенность данных для таких полей это то, что они должны быть в исходном формате т/е JSON. Что бы узнать точно в каком формате у вас данные сделайте либо экспорт нужного поля, либо найдите его значение в базе данных.

## События

Вы можете писать свои плагины подписывая их на события.

**msieOnStartImportProduct** — срабатывает перед стартом импорта.

- **file** — путь к файлу импорта
- **msie** — объект класса Msie, со всеми методами

**msieOnBeforePrepareImportProduct** — срабатывает перед началом обработки данных импорта.

- **data** — входные данные импорта
- **fields** — массив названий полей импорта
- **msie** — объект класса Msie, со всеми методами

**msieOnEqualPageTitleImportProduct** — срабатывает когда происходит добавление/обновления товара название
которого (pagetitle) уже есть в том же каталоге (одинаковый родитель). Если это никак не обработать то modx
сгенерирует ошибку:

```
uri: Ресурс с идентификатором ID уже использует URI alias: Ресурс с идентификатором ID уже использует URI.
Пожалуйста, введите уникальный псевдоним или используйте «Заморозить URI», чтобы вручную заменить его.
```

- **mode** — действие (create|update)
- **productId** — ID товара у которого дакой же pagetitle
- **srcData** — входные данные импорта
- **destData** — данные которые прошли подготовку для импорта (попадают в процессор импорта)
- **fields** — массив названий полей импорта
- **msie** — объект класса Msie, со всеми методами

Генерация данного события по умолчанию отключена в настройках импорта (опция “Проверять название товара на дублирование”) т.к она генерирует лишний запрос к БД, поэтому если вы уверен что у вас не будет одинаковых названий у товаров в пределах одного родителя то ее включать не стоит.

**Пример обработки такого события:**

```php
<?php
/** @var modX $modx */
switch ($modx->event->name) {
  case 'msieOnEqualPageTitleImportProduct':
    $postfixAliasFieldName = 'article';
    $destData = $modx->event->params['destData'];
    $postfixAlias = isset($destData[$postfixAliasFieldName]) ? $destData[$postfixAliasFieldName] : '';

    if ($postfixAlias && $destData['pagetitle']) {
      $res = $modx->newObject('modResource');
      $alias = $res->cleanAlias($destData['pagetitle']);
      $delimiter = $modx->getOption('friendly_alias_word_delimiter', null, '-');
      $destData['alias'] = $alias . $delimiter . $postfixAlias;
      $modx->event->returnedValues['skip'] = false; // не пропускать импорт данного товара т.к был создан уникальный alias
      $modx->event->returnedValues['destData'] = $destData;
    }

    break;
}
```

**msieOnBeforeImportProduct** — срабатывает перед импортом товара.

- **mode** — действие (create|update)
- **srcData** — входные данные импорта
- **destData** — srcData данные которые прошли подготовку для импорта (попадают в процессор импорта)
- **fields** — массив названий полей импорта
- **msie** — объект класса Msie, со всеми методами

**msieOnAfterImportProduct** — срабатывает после импорта товара.

- **mode** — действие (create|update)
- **srcData** — входные данные импорта
- **destData** — данные которые прошли подготовку для импорта
- **data** — данные товара
- **fields** — массив названий полей импорта
- **msie** — объект класса Msie, со всеми методами

**msieOnCompleteImportProduct** — срабатывает после окончания импорта товаров.

- **data** — строки с ID товарами через запятую которые были добавлены/обновлены
- **msie** — объект класса Msie, со всеми методами

Пример плагина который отменяет у товара публикацию если он не попал в файл импорта:

```php
<?php
/** @var modX $modx */
switch ($modx->event->name) {
  case 'msieOnCompleteImportProduct':
    // Массив ID настроек полей для которых нужно использовать данный плагин http://prntscr.com/kkwx4r
    $presets = array();
    if (!in_array($preset, $presets)) return;
    // Получаем id всех товаров которые были импортированы
    if (!$ids = $modx->event->params['data']) return;
    // Снимаем с публикации товары которые не попали в файл импорта
    $sql = "UPDATE {$modx->getTableName('msProduct')} SET published = 0 WHERE class_key = 'msProduct' AND id NOT IN ({$ids});";
    // $sql = "UPDATE {$modx->getTableName('msProductData')} SET my_custom_field = 0 WHERE id NOT IN ({$ids});";
    $modx->exec($sql);

    break;
}
```

**msieOnStartUpdateProduct** — срабатывает перед стартам обновления товаровов.

- **fields** — массив названий полей
- **preset** — ID настройки полей
- **msie** — объект класса Msie, со всеми методами

**msieOnBeforePrepareUpdateProduct** — срабатывает перед началом обработки данных.

- **data** — входные данные
- **fields** — массив названий полей
- **msie** — объект класса Msie, со всеми методами

**msieOnBeforeUpdateProduct** — срабатывает перед началом обновления товара.

- **data** —данные которые прошли подготовку дял обновления
- **fields** — массив названий полей
- **msie** — объект класса Msie, со всеми методами

Для того чтобы пропустить обновления товара в плагине можно присвоить переменной skip значение true.

**Пример:**

```php
<?php
/** @var modX $modx */
switch ($modx->event->name) {
  case 'msieOnBeforeUpdateProduct':
    $modx->event->returnedValues['skip'] = true; // пропустить обновление товара
  break;
}
```

**msieOnCompleteUpdateProduct** — срабатывает после окончания обновления всех товаров.

- **msie** — объект класса Msie, со всеми методами

**msieOnStartImportOptionsPrice2** — срабатывает перед стартам импорта всех модификаций.

- **file** — путь к файлу импорта
- **preset** — ID настройки полей
- **msie** — объект класса Msie, со всеми методами

**msieOnBeforeImportOptionsPrice2** — срабатывает перед импортом модификации.

- **productId** — ID товара
- **msie** — объект класса Msie, со всеми методами

**msieOnAfterImportOptionsPrice2** — срабатывает после импортом модификации.

- **data** — данные модификации
- **productId** — ID товара
- **msie** — объект класса Msie, со всеми методами

**msieOnCompleteImportOptionsPrice2** — срабатывает после окончания импорт модификаций.

- **msie** — объект класса Msie, со всеми методами

**msieOnCompleteImportGallery** — срабатывает после окончания импорта в фото галерею.

- **msie** — объект класса Msie, со всеми методами

**msieOnCompleteImportLinks** — срабатывает после окончания импорта связей.

- **msie** — объект класса Msie, со всеми методами

**msieOnBeforeExportQuery** — срабатывает перед sql запросом выборки данных:

- **type** — (products|categories|links|options_price2)
- **preset** — ID настройки полей
- **data** — массив параметров для sql запроса
- **fields** — массив названий полей
- **msie** — объект класса Msie, со всеми методами

**Пример** изменения параметра where. Добавление условия на выборку товара цена которого больше 100 и ID пресета 3 или 5

```php
<?php
/** @var modX $modx */
$presets = array(3,5); // Массив ID   настроек полей для которых нужно использовать данный плагин http://prntscr.com/kkwx4r
if (!empty($presets) && !in_array($preset, $presets)) return;
switch ($modx->event->name) {
  case 'msieOnBeforeExportQuery':
    $where = $modx->fromJSON($modx->getOption('where', $data, '[]', true));
    $where['Data.price:>'] = 100;
    $data['where'] = $modx->toJSON($where);
    $modx->event->returnedValues['data'] = $data;

    break;
}
```

**msieOnCompleteExport** — срабатывает после окончания экспорта.

- **to** — (csv|xlsx|xml)
- **type** — (products|categories|links|options_price2)
- **file** — путь к файлу
- **msie** — объект класса Msie, со всеми методами

**msieOnBeforeExport** — срабатывает перед экспортом каждого элемента.

- **type** — (products|categories|links|options_price2)
- **srcData** — входные данные
- **destData** — данные которые прошли подготовку
- **fields** — массив названий полей
- **msie** — объект класса Msie, со всеми методами

**msieOnCompleteExport** — срабатывает после окончания экспорта.

- **to** — (csv|xlsx|xml)
- **type** — (products|categories|links|options_price2)
- **file** — путь к файлу
- **msie** — объект класса Msie, со всеми методами

**Пример** плагина который только для нового товара модифицирует его цену перед созданием.

```php
<?php
/** @var modX $modx */
switch ($modx->event->name) {
  case 'msieOnBeforeImportProduct':
    if ($mode == 'create') {
      $modx->event->params['destData']['price'] = $modx->event->params['destData']['price'] + 100;
      $modx->event->returnedValues['destData'] = $modx->event->params['destData'];
    }
    //$modx->event->returnedValues['skip'] = true; // пропустить импорт товара
    //$modx->log(modX::LOG_LEVEL_ERROR, print_r($modx->event->params, 1));
    //$modx->event->output('Error');

    break;
}
```

## Импорт больших файлов

Если ваши файлы импорта достаточно большие, то возможно вам понадобится сделать предварительную настройку сетвара.

1. Отредактировать php.ini увеличив значения для upload_max_filesize и post_max_size
2. Увеличить timeout для Apache или Nginx

   a) Nginx и PHP-FPM (В этом случае Nginx будет ждать 300 секунд)

    ```nginx
    http {
      ...
      fastcgi_connect_timeout 300s;
      fastcgi_send_timeout 300s;
      fastcgi_read_timeout 300s;
      ...
    }
    ```

    b) Nginx используется как прокси-сервер (Nginx + Apache)

    ```nginx
    server {
      ...
      proxy_connect_timeout 300s;
      proxy_send_timeout 300s;
      proxy_read_timeout 300s;
      send_timeout 300s;
      ...
    }
    ```

    Не забывайте перезапускать Nginx после изменения настроек: nginx -s reload

3. MySQL my.cnf. Увеличить значения для max_allowed_packet и wait_timeout. Не забывайте перезапускать MySQL
