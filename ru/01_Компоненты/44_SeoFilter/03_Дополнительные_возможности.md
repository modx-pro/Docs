Здесь собраны все нераскрытые ранее возможности. Возможно, они вам не пригодятся, но некоторых могут сильно выручить. Весь этот функционал полностью задействован на одном проекте и, что самое важное, он универсален и подходит для всех сайтов.

## Автоматические действия

Этот пункт не требует от вас каких-либо действий, но, чтобы не удивляться в работе, следует знать и про это.

### Автоматический сбор новых слов

После добавления новых полей в первую вкладку SeoFilter, компонент будет отслеживать изменения в ресурсах, которые ограничиваются этими системными настройками:

| Название                | По умолчанию | Описание                                                                     |
| ----------------------- | ------------ | ---------------------------------------------------------------------------- |
| **seofilter_classes**   | msProduct    | Типы ресурсов (сlass_key) для отслеживания плагином. Несколько через запятую |
| **seofilter_templates** |              | Id шаблонов (template) для отслеживания плагином. Несколько через запятую    |

Помимо такого отслеживания, есть добавление слов через сниппет [sfWord][2]. Это не основная функция сниппета, а побочная. Слово будет добавлено, если оно не найдено в словаре. Про весь функционал - на отдельной странице ["Сниппеты"][0].

Если вы отключили отслеживание ресурсов и не вызываете сниппет sfWord, то о новых словах компонент будет узнавать при работе с mFilter2 через Ajax.

И даже если вы отключили работу компонента через Ajax, то остаётся один вариант - добавлять их в ручную. Синоним пропишется самостоятельно, если не указан.

![](https://file.modx.pro/files/2/5/c/25cf4a517b9448fea7e43bfe2eedae7b.jpg)

#### Автоматически изменяются alias'ы при изменении в поле и словаре

Такая "фича" очень облегчает жизнь, если вы уже прописали в шаблонах замены, используя, к примеру, плейсхолдер `{$color}` (потому что синоним в фильтре и для поля цвет - **color**). А потом решили, что для поисковиков было бы лучше использовать не английское слово, а транлитирированное - **сvet**.

Теперь, после переименования синонима в поле, все упоминания в текстах и url-адресах, связанные с этим полем, будут заменены.

> функция экспериментальная, перепроверяйте тексты после серьёзных замен.

Такая же ситуация с синонимом слова - при его изменении изменятся URL адреса сгенерированных таблиц, а старые адреса будут отдавать ошибку 404.

## Склонения слов

Склонение по падежам происходит через сервис morpher.ru. За всё отвечает 3 настройки. Рекомендую зарегистрироваться на сервисе, получить токен и прописать его в системных настройках компонента. К простому склонению слова по падежам возвращаеются падежи и во множественном числе.

| Название                    | По умолчанию | Описание                                                                |
| --------------------------- | ------------ | ----------------------------------------------------------------------- |
| **seofilter_decline**       | Нет          | Активирует функцию склонения. Лимит бесплатных запросов - 1000 в сутки. |
| **seofilter_morpher_token** |              | Токен, полученный в сервисе morpher.ru                                  |

При добавлении нового слова, при включённой настройке **seofilter_decline**, всё происходит автоматически. Об ошибках работы или склонения в журнале ошибок появится соответствующая запись.

## Значения полей в других таблицах

Одна из самых важных функций. Сразу же приведу пример как это работает в боевом проекте. Я за целостность данных, поэтому люблю хранить в полях msProductData ID со сторонних таблиц. На скриншоте в качестве сторонней таблицы было использовано дополнение [customExtra][3], а в самом "товаре" поля для метро с функцией выбора из списка был организовано через дополнение msFieldsManager.

[![](https://file.modx.pro/files/b/c/5/bc568ec2dc521c333443d7f3dba6cd10.jpg)](https://file.modx.pro/files/b/c/5/bc568ec2dc521c333443d7f3dba6cd10.jpg)

В таком случае в словаре в запросах будут id записей из другой таблицы, а в значениях - их человеко-понятное название. Все падежи образуются от **Значения**.

![](https://file.modx.pro/files/4/a/f/4af3a0d36bc8bc1d84a0c49dca7630c2.jpg)

## Зависимые поля и слова

Функция довольно таки новая и при её активации выпадает ещё 2 поля для ввода.

Допустим у нас каталог автомобилей и мы уже добавили поле Марка, а сейчас добавляем Модель. И теперь в появившееся поле "Зависит от" мы выбираем уже ранее добавленную Марку. А в следующее "По столбцу" впишем marka. (всё это будет хорошо работать, если марки и модели хранятся в таблицах собственного компонента или например, в таблицах customExtra).

Всё это нужно, чтобы не получить при пересечении Марки и модели авто такие казусы:
BMW Q5, BMW Хантер, УАЗ X5 и т.д. Чтобы не тратить на них лишние ресурсы при подсчёте и не мучиться с лишними ссылками.

На скриншоте поле Коллекция зависит от поля Производитель.

![](https://file.modx.pro/files/7/4/d/74dd3a15eaaafd1c873ae1e714b78745.jpg)

Соответсвенно и слова будут зависеть от других слов. Поле **Зависит от** появляется, когда выбранное значение в поле **Поле** зависит от другого поля.

![](https://file.modx.pro/files/7/4/7/747f5b6d3b7f7341870e6cae95af3a0f.jpg)

## Условия для полей в правилах

Этот функционал нужен для того, чтобы создавать правила генерации виртуальных страниц из определённых значений полей. Абстрактный пример: допустим, у нас есть фильтрация по производителям (Apple, Epson) и категориям продукции (смартфоны, ноутбуки, принтеры). Мы знаем, что Apple не производит принтеры, а Epson не делает телефоны и ноутбуки. Поэтому не совсем корректно создавать правило из полей  **Производитель + Категория** и прописывать одни шаблоны текстов на сильно-разные страницы. Гораздо удобнее сделать так:

1. Создать правила, например, "**Техника Apple**" и "**Принтеры Epson**".
2. Добавить в правило поля: **Категория** и **Производитель**
    2.1. Ограничить каждое поле условиями при добавлении поля (скриншот)
3. Прописать соответствующие правилам SEO-тексты.
4. Сохранить правило и убедиться, что всё работает.

[![](https://file.modx.pro/files/0/0/d/00d1faf78a792782a13b1dc6a89978a4s.jpg)](https://file.modx.pro/files/0/0/d/00d1faf78a792782a13b1dc6a89978a4.jpg)

### Операция сравнения

При добавлении условия к полю доступны несколько операций сравнения/ограничения:

* **Содержится** - правило будет применено только к словам, запросы которых **перечислены** ниже через запятую.
* **Не содержится** - правило будет применено к словам, запросы которых **НЕ перечислены** в поле ниже.
* **Больше** - правило сработает для числовых полей, которые **строго больше** значения (только одно значение).
* **Меньше** - правило для тех запросов, что **строго меньше** значения в нижнем поле.
* **В диапазоне** - вводить 2 числа через запятую. Для полей, удовлятворяющих условию: **Больше 1-го числа и меньше 2-го.**

В поле **Значение** можно вписывать одно или несколько значений через запятую. Текстовые запросы также обрабатываются и туда можно писать такие строки без кавычек: `красный,зеленый`. Сравнения "Больше", "Меньше" и "В диапазоне" позволят создать страницы, отвечающие запросу "недорогие". Вы сами определяете, какие товары у вас недорогие, задавая значения.

Если у вас уже было создано правило, то при ограничении полей лишние ссылки автоматически удалятся. Останутся лишь те, что удовлетворяют условиям.

## Подсчёт потомков в правилах

Функционал нужен для упоминания в текстах подобных строк: **В нашем каталоге 150 телефонов**. По умолчанию отключено. За подсчёт отвечает класс pdoFetch из pdoTools, который обрабатывает все условия. Активировать можно в системной настройке:

| Название            | По умолчанию | Описание                                                                             |
| ------------------- | ------------ | ------------------------------------------------------------------------------------ |
| **seofilter_count** | Нет          | Активирует подсчёт потомков и делает доступным в SEO текстах плейсхолдер `{$count}`. |

После активации в редактировании правил откроются скрытые поля:

![](https://file.modx.pro/files/7/6/5/765786e84c1c6459a04ba99db2ac273b.jpg)

По умолчанию подсчёт потомков ничем не ограничен. Он ищет потомков выбранной страницы из списка и учитывает только значения выбранных полей. Никак не учитывает опубликованные, скрытые или удалённые ресурсы (у каждого могут быть ещё дополнительные парметры). Для управления подсчётами в каждом правиле есть два поля-настройки.

* **Доп. условие для подсчёта ресурсов** -- строка в JSON формате, обычно я прописываю `{"published":1,"deleted":0}`, так как в каталоге показываю только опубликованные и не удалённые ресурсы.
* **Parents** -- поле, аналогичное параметру parents в pdoResources. Если у вас на странице товары/ресурсы выводятся из нескольких родителей или страница с фильтром фильтрует не по своим потомкам, то нужно обязательно прописать id родителей.

## Выборки по мин/макс параметрам

По умолчанию отключены и, чтобы работали выборки, нужно включить настройку подсчёта потомков. Функционал тесно связан с подсчётами и позволяет в текстах генерировать такие строки: **В нашем каталоге 150 телефонов от 1000 руб.**  За выборки также отвечает класс pdoFetch из pdoTools, к которому тоже применяются все условия. А для определения что и по чему выбирать, есть две системные настройки, значения к которым можно задавать через запятую.

| Название             | Описание                                                            | Пример записи                                  |
| -------------------- | ------------------------------------------------------------------- | ---------------------------------------------- |
| **seofilter_choose** | По каким полям ресурса выбирать минимальные и максимальные значения | `msProductData.price`                          |
| **seofilter_select** | Какие поля из этих двух ресурсов выбирать.                          | `id,msProductData.price,msProductData.made_in` |

Нужно понимать, что количество плейсхолдеров будет получено перемножением друг на друга и на 2. В данном примере будет доступно `2(min,max) x 1(price) x 3(id,price,made_in) = 6` плейсхолдеров для использования в текстах по такой маске: `{$[min]_[choose]_[select]}`:

* `{$min_price_id}` - ID самого дешевого товара.
* `{$min_price_price}` - Цена самого дешевого товара.
* `{$min_price_made_in}` - Страна производства самого дешевого товара.
* `{$max_price_id}` - ID самого дорогого товара и так далее...

Есть небольшие "фичи" в настройках, которые позволяют укоротить плейсхолдеры:

1. В настройке **seofilter_choose** допустимо писать синоним для ключа поля. Например, при выборке по `msProductData.old_price`, вы бы получали плейсхолдеры `{$max_old_price_id}` ,что может запутать. А прописав в настройке синоним к полю через **"="** `msProductData.old_price=op` , плейсхолдеры станут такими {$min_op_price}, что уже приятнее.
2. В настройке **seofilter_select** можно сделать также. Но здесь уже в другом формате -- через **" as "**, вот так: `id,msProductData.old_price as op`.

В итоге, по сокращению плейсхолдеров, можно добиться с такого: `{$min_price_made_in}` до такого `{$min_p_in}`.

## PrepareSnippet для обработки текстов

Казалось бы, если есть Fenom, то зачем ещё дополнительно обрабатывать тексты? А всё для большей гибкости и расширения возможностей. Принцип работы такой же, как в pdoTools. В сниппет попадает массив параметров перед использованием их в текстах, которые вы можете изменять или добавлять. А вернуть он должен **serialize($row)**. Входные параметры, доступные в сниппете:

| Название       | Описание                                                                                                                                                                                                                          |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **$row**       | Непосредственно сам массив замен содержит в себе слова, склонения, подсчёты. Именно в $row нужно записывать новые значения и работать со старыми.                                                                                 |
| **$rule_id**   | Id правила, чтобы можно было обрабатывать только некоторые правила, которые требуют дополнительных данных. Если **$rule_id** пустой, это значит, что будут выведены поля ресурса по умолчанию, в них также могут работать замены. |
| **$page_id**   | Id страницы, куда будут отправлены результаты.                                                                                                                                                                                    |
| **$input**     | слово, точнее его запрос из словаря (для правил состоящих из одного поля).                                                                                                                                                        |
| **$pdoTools**  | класс pdoTools со всеми методами, точнее **pdoFetch**. Доступен синоним **$pdoFetch**.                                                                                                                                            |
| **$seoFilter** | класс SeoFilter, публичные методы которого можно использовать (только для тех, кто смотрит код).                                                                                                                                  |

За **включение prepareSnippet** отвечает системная настройка **seofilter_snippet**, куда нужно прописать название вашего сниппета. Если что-то не будет работать, в логе будет соответствуюшая запись.

## Работа в таблице URL

Изначально компонент планировался как полностью динамичный, который бы хранил только слова и правила с url-маской, постоянно подставляя синонимы в url. Но с такой таблицей стали доступны такие удобства:

* можно задавать индивидуальные адреса, даже игнорируя текущую вложенность;
* использовать индивидуальные мета-теги;
* подсчитывать количество переходов для выявления наиболее популярных страниц;
* отключать страницы, которые точно не нужны -- например, где нет ресурсов или один;
* управлять пунктами меню, формировать карту сайта (в следующих версиях);

### Показывать в меню для сгенерированных ссылок

В одном из проектов я уже активно использю эту функцию, но выборку делаю самостоятельным неуниверсальным сниппетом. Так как ссылки -- это обычные объекты со своими полями, с которыми можете ознакомиться в xml схеме компонента. Вскоре планирую добавить сниппет для формирования меню и карты сайта.

### Сбросить счётчики просмотров

В верхней части таблицы есть кнопка **Ещё** - внутри **Сбросить счётчики**, которая обнуляет количество переходов на страницу по ссылкам и через Ajax. Нужна тогда, когда вы проводите какие-то работы, накрутили переходы самостоятельно на множестве страниц и для большей верности стоит сбросить все счётчики страниц. Конечно, и на каждой странице можно сделать это вручную.  

### Пересчитать результаты

В верхней части таблицы есть кнопка **Ещё** - внутри **Пересчитать результаты**, которая запустит пересчёт по каждой ссылке всеx результатов. Предварительно нужно убедиться, что включены подсчёты, в правилах прописаны верные дополнительные условия. Все результаты будут записаны в каждую ссылку, чтобы можно было использовать быстрый режим меню, карты сайта без постоянных пересчётов.

## Хлебные крошки на AJAX

Стандартный функционал заточен под чанк tpl.SeoFilter.crumbs.current, который идёт в комплекте. Для тех, кто использует pdoCrumbs, достаточно указать параметр в вызове сниппета:

```php
&tplCurrent=`tpl.SeoFilter.crumbs.current`
```

 В чанке можно посмотреть и по желанию раскомментировать часть кода, чтобы возвращать ссылку на текущую страницу. Семантически правильные крошки, где есть указание позиции тоже можно сделать, есть параметр idx.

Кому не нужны замены — можно ничего не менять и отключить системную настройку seofilter_crumbs_replace.

## Интеграция с tvSuperSelect

[tvSuperSelect][5] - удобный компонент, который делает из TV поле, похожее на теги в miniShop2. При чём хранит слова в сторонней таблице.

Для интеграции достаточно добавить Поле в SeoFilter выбрав класс **modTemplateVar**, введя в ключ название вашего TV поля. И для правильных подсчётов по нему нужно поставить галочку **Значение в другой таблице** и прописать **tvuperselect** в первом поле «Компонент, например customextra:»

## Интеграция с FrontendManager

[FrontendManager][4] -- бесплатный компонент, позволяющий быстро и удобно редактировать страницы, настройки, заказы с фронтальной части сайта, размещая своё меню в верху или внизу страницы. Сам пользуюсь компонентом, поэтому для большего удобства работы с SeoFilter был разработан отдельный контроллёр -- для быстрого редактирования виртуальной SEO страницы. Интеграция не автоматическая. Нужно сделать эти действия, чтобы всё заработало:

1. Системные настройки FrontendManager позволяют переопределить чанк верхней панели, css и js файлы как на фронте, так и в админке. **Нам нужно изменить лишь чанк и js-файл для админки**, чтобы будущие обновления не затирали наши правки.
2. В копии чанка **tpl.frontendmanager.seo** *(.seo - моя копия)*  - перед закрытием `</div>` вставляем код:

```php
<a href="[[++manager_url]]?a=seoedit&namespace=seofilter&id={$_modx->getPlaceholder('sf.seo_id')}" data-action="iframe" data-url="[[++manager_url]]?a=seoedit&namespace=seofilter&id=" class="fm-seofilter {if $_modx->getPlaceholder('sf.seo_id')?}{else}hidden{/if}"><span>SEO</span></a>
```

3. **В копии js файла** (а по умолчанию он здесь: /assets/components/frontendmanager/js/mgr/manager.js) вставляем после первой строки `Ext.onReady(function() {` следующий код:

```javascript
 if(Ext.getCmp("seofilter-panel-seoedit")) {
        Ext.getCmp("seofilter-panel-seoedit").on("success", function(e){
            if(e.result.message) {
                top.window.location.href = e.result.message;
            } else {
                reloadFrontendManager();
            }
        });
    }
```

Теперь немного объясню что и как работает:

1. SeoFilter выставляет плейсхолдер **sf.seo_id**, если текущая страница относится к какому-нибудь правилу и url был найден в таблице.
2. При Ajax работе совместно с mFilter2, компонент на лету заменяет ссылку в панели frontendManager, используя склейку data-url и полученного seo_id. То есть не нужно обновлять страницу, чтобы открыть быстрое редактирование.
3. Если правило было не найдено или не удовлетворяет текущему адресу, то пункт SEO из панели будет скрыт за счёт стандартного класса: **hidden**. Скрытием и закрытием управляет js-файл компонента SeoFilter, который тоже можно переопределить в системных настройках.
4. А правки в JS файле нужны, чтобы frontendManager обновил страницу после ваших правок. Если же вы изменили индвидуальный адрес страницы, то при стандартном обновлении страницы вы получите ошибку 404. Чтобы этого избежать, есть строка: `top.window.location.href = e.result.message;`. При смене индивидуального URL контроллёр SeoFilter формирует новый адрес и записывает его в **result.message**, чтобы обновление страницы работало корректно, перенаправляя на новый адрес.
5. Само быстрое редактирование выглядит так: (кликабельно)

[![](https://file.modx.pro/files/5/e/f/5ef4576c1f53676068bbc84fac14dee2s.jpg)](https://file.modx.pro/files/5/e/f/5ef4576c1f53676068bbc84fac14dee2.jpg)

> Внимание! По умолчанию, в таком режиме сразу выводятся SEO поля (Заголовки, тексты). При их изменении, за исключением поля Контент (так как там подгружается редактор Ace, если он установлен у вас), автоматически поставится галочка: **Использовать индивидуальные мета-теги**. Если вы передумали задавать индивидуальные тексты, то нужно в ручную убрать галочку или не сохранять, а просто закрыть.

Если у вас есть вопросы, то можете задавать их на modx.pro в топиках про SeoFilter.

[0]: /ru/01_Компоненты/44_SeoFilter/01_Быстрый_старт_с_mFilter2.md
[1]: /ru/01_Компоненты/44_SeoFilter/04_Сниппеты
[2]: /ru/01_Компоненты/44_SeoFilter/04_Сниппеты/01_sfWord.md
[3]: /ru/01_Компоненты/16_customExtra.md
[4]: https://modstore.pro/packages/utilities/frontendmanager
[5]: https://modstore.pro/packages/other/tvsuperselect
